<!DOCTYPE html>
<html lang="pt-BR" data-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Editor de Funil - BudZap</title>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/jsplumb@2.15.6/dist/js/jsplumb.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>
    <style>
        body {
            font-family: 'Poppins', sans-serif;
            overflow: hidden;
        }

        .node-message { background-color: #E3F2FD; border-left: 4px solid #2196F3; }
        .node-input { background-color: #E8F5E9; border-left: 4px solid #4CAF50; }
        .node-condition { background-color: #FFF3E0; border-left: 4px solid #FF9800; }
        .node-wait { background-color: #F3E5F5; border-left: 4px solid #9C27B0; }
        .node-image { background-color: #FCE4EC; border-left: 4px solid #E91E63; }
        .node-audio { background-color: #E8EAF6; border-left: 4px solid #3F51B5; }
        .node-video { background-color: #FFEBEE; border-left: 4px solid #F44336; }
        .node-file { background-color: #ECEFF1; border-left: 4px solid #607D8B; }

        .canvas {
            width: 5000px;
            height: 5000px;
            position: relative;
            background-color: #f0f4f8;
            background-image: 
                radial-gradient(#e6e6e6 1px, transparent 1px),
                radial-gradient(#e6e6e6 1px, transparent 1px);
            background-size: 20px 20px;
            background-position: 0 0, 10px 10px;
            transform-origin: 0 0;
        }

        .canvas-container {
            width: 100%;
            height: calc(100vh - 64px);
            overflow: auto;
            cursor: grab;
        }

        .canvas-container:active {
            cursor: grabbing;
        }

        .node {
            position: absolute;
            width: 250px;
            border-radius: 8px;
            background-color: white;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            cursor: move;
            user-select: none;
            transition: all 0.3s ease;
        }

        .node:hover {
            box-shadow: 0 6px 8px rgba(0, 0, 0, 0.15);
            transform: translateY(-2px);
        }

        .node-header {
            padding: 10px;
            border-bottom: 1px solid #e2e8f0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-top-left-radius: 8px;
            border-top-right-radius: 8px;
        }

        .node-content {
            padding: 10px;
            word-break: break-word;
        }

        .endpoint-label {
    pointer-events: none;
    user-select: none;
    font-size: 12px;
    font-weight: bold;
    color: white;
    text-shadow: 1px 1px 2px rgba(0,0,0,0.7);
}

.endpoint-yes {
    background-color: #48BB78 !important;
}

.endpoint-no {
    background-color: #F56565 !important;
}

        .endpoint:hover {
            transform: scale(1.2);
        }

       

        .node-footer {
            position: relative;
            height: 20px;
        }

        .fixed-menu {
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        background-color: white;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1), 0 1px 3px rgba(0, 0, 0, 0.08);
        border-radius: 12px;
        padding: 12px;
        z-index: 1000;
        width: 90%;
        max-width: 800px;
    }

    .menu-tabs {
        display: flex;
        justify-content: space-around;
        margin-bottom: 12px;
        border-bottom: 1px solid #e2e8f0;
    }

    .menu-tab {
        padding: 8px 16px;
        cursor: pointer;
        border-bottom: 2px solid transparent;
        transition: all 0.3s ease;
    }

    .menu-tab.active {
        border-bottom-color: #3b82f6;
        color: #3b82f6;
    }

    .menu-content {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
        gap: 12px;
    }

    .menu-item {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        padding: 12px;
        border-radius: 8px;
        background-color: #f3f4f6;
        transition: all 0.3s ease;
        cursor: pointer;
    }

    .menu-item:hover {
        background-color: #e5e7eb;
        transform: translateY(-2px);
    }

    .menu-item svg {
        width: 24px;
        height: 24px;
        margin-bottom: 8px;
    }

    .menu-item span {
        font-size: 12px;
        text-align: center;
    }
        .btn {
            transition: all 0.3s ease;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .jtk-connector {
            z-index: 4;
        }

        .jtk-endpoint {
            z-index: 5;
        }

        .jtk-overlay {
            z-index: 6;
        }

        .media-preview {
        max-width: 100%;
        max-height: 100px;
        object-fit: contain;
    }

    .media-preview img,
    .media-preview video {
        max-width: 100%;
        max-height: 100px;
        object-fit: contain;
    }

    .media-preview audio {
        width: 100%;
    }

        .zoom-controls {
            position: fixed;
            top: 80px;
            right: 20px;
            z-index: 1000;
        }

        @media (max-width: 640px) {
            .fixed-menu {
                bottom: 0;
                left: 0;
                right: 0;
                flex-direction: row;
                justify-content: space-around;
            }
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen flex flex-col">
    <nav class="bg-white shadow-md p-4">
        <div class="container mx-auto flex justify-between items-center">
            <h1 class="text-xl font-bold text-gray-800 flex items-center">
                <svg class="w-6 h-6 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 5l7 7-7 7M5 5l7 7-7 7"></path>
                </svg>
                <span id="funnelName"><%= funnel.name %></span>
            </h1>
            <button onclick="saveFunnel()" class="btn bg-green-500 text-white px-4 py-2 rounded-full hover:bg-green-600 transition duration-300 flex items-center">
                <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7H5a2 2 0 00-2 2v9a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-3m-1 4l-3 3m0 0l-3-3m3 3V4"></path>
                </svg>
                Salvar
            </button>
        </div>
    </nav>

    <div class="zoom-controls">
        <button onclick="zoomIn()" class="btn bg-blue-500 text-white p-2 rounded-full hover:bg-blue-600 transition duration-300">
            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6v6m0 0v6m0-6h6m-6 0H6"></path>
            </svg>
        </button>
        <button onclick="zoomOut()" class="btn bg-blue-500 text-white p-2 rounded-full hover:bg-blue-600 transition duration-300 mt-2">
            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20 12H4"></path>
            </svg>
        </button>
    </div>

    <main class="flex-1 overflow-hidden">
        <div id="canvas-container" class="canvas-container">
            <div id="canvas" class="canvas">
                <!-- Os nós do fluxo serão renderizados aqui -->
            </div>
        </div>
    </main>

    <div class="fixed-menu">
        <div class="menu-tabs">
            <div class="menu-tab active" onclick="showTab('messages')">Mensagens</div>
            <div class="menu-tab" onclick="showTab('logic')">Lógica</div>
            <div class="menu-tab" onclick="showTab('actions')">Ações</div>
        </div>
        <div class="menu-content" id="menuContent">
            <!-- Conteúdo será preenchido dinamicamente via JavaScript -->
        </div>
    </div>
    

    <!-- Modal para edição de nós -->
    <div id="editModal" class="fixed z-10 inset-0 overflow-y-auto hidden">
        <div class="flex items-end justify-center min-h-screen pt-4 px-4 pb-20 text-center sm:block sm:p-0">
            <div class="fixed inset-0 transition-opacity" aria-hidden="true">
                <div class="absolute inset-0 bg-gray-500 opacity-75"></div>
            </div>
            <span class="hidden sm:inline-block sm:align-middle sm:h-screen" aria-hidden="true">&#8203;</span>
            <div class="inline-block align-bottom bg-white rounded-lg text-left overflow-hidden shadow-xl transform transition-all sm:my-8 sm:align-middle sm:max-w-lg sm:w-full">
                <div class="bg-white px-4 pt-5 pb-4 sm:p-6 sm:pb-4">
                    <h3 class="text-lg leading-6 font-medium text-gray-900" id="modalTitle"></h3>
                    <div class="mt-2" id="modalContent"></div>
                </div>
                <div class="bg-gray-50 px-4 py-3 sm:px-6 sm:flex sm:flex-row-reverse">
                    <button type="button" class="w-full inline-flex justify-center rounded-md border border-transparent shadow-sm px-4 py-2 bg-blue-600 text-base font-medium text-white hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 sm:ml-3 sm:w-auto sm:text-sm" onclick="saveNodeEdit()">
                        Salvar
                    </button>
                    <button type="button" class="mt-3 w-full inline-flex justify-center rounded-md border border-gray-300 shadow-sm px-4 py-2 bg-white text-base font-medium text-gray-700 hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 sm:mt-0 sm:ml-3 sm:w-auto sm:text-sm" onclick="closeModal()">
                        Cancelar
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script>
    let jsPlumbInstance;
    let nodes = [];
    let connections = [];
    let editingNodeId = null;
    let zoomLevel = 1;
    let isDragging = false;
    let startX, startY, scrollLeft, scrollTop;
    let container;

    document.addEventListener('DOMContentLoaded', function() {
        container = document.querySelector('.canvas-container');

        jsPlumbInstance = jsPlumb.getInstance({
            Connector: ["Bezier", { curviness: 50 }],
            Anchors: ["Right", "Left"],
            Endpoint: ["Dot", { radius: 5 }],
            PaintStyle: { stroke: "#6366F1", strokeWidth: 2 },
            HoverPaintStyle: { stroke: "#4338CA" },
            
            ConnectionOverlays: [
                ["Arrow", { 
                    location: 1,
                    width: 10,
                    length: 10,
                    foldback: 0.7
                }]
            ]
        });

        jsPlumbInstance.setContainer("canvas");
        
        // Carregar o funil existente
       // Carregar o funil existente
    const savedFunnel = <%- JSON.stringify(funnel) %>;
    if (savedFunnel && savedFunnel.nodes) {
        savedFunnel.nodes.forEach(node => addNode(node.type, node));
        savedFunnel.connections.forEach(conn => {
            createConnection(conn.sourceId, conn.targetId, conn.anchors);
        });
        
        // Centralizar na primeira caixa após carregar o funil
        if (savedFunnel.nodes.length > 0) {
            setTimeout(() => focusOnNode(savedFunnel.nodes[0].id), 100);
        }
    }

        // Adicionar evento de zoom com a roda do mouse
        container.addEventListener('wheel', function(e) {
            if (e.ctrlKey) {
                e.preventDefault();
                const delta = e.deltaY > 0 ? -0.1 : 0.1;
                zoom(delta);
            }
        });

        // Adicionar eventos para arrastar a tela
        container.addEventListener('mousedown', startDragging);
        container.addEventListener('mousemove', drag);
        container.addEventListener('mouseup', stopDragging);
        container.addEventListener('mouseleave', stopDragging);

        // Atualizar os event listeners dos botões para usar addNewNode
        document.querySelectorAll('.fixed-menu button').forEach(button => {
            const nodeType = button.getAttribute('onclick').match(/addNewNode\('(\w+)'\)/)[1];
            button.removeAttribute('onclick');
            button.addEventListener('click', () => addNewNode(nodeType));
        });

        // Inicialização
        updateCanvasSize();
        centerCanvas();
    });

    function addNewNode(type) {
        const canvas = document.getElementById('canvas');
        const canvasRect = canvas.getBoundingClientRect();
        let newLeft, newTop;

        if (nodes.length > 0) {
            const lastNode = nodes[nodes.length - 1];
            const lastNodeElement = document.getElementById(lastNode.id);
            if (lastNodeElement) {
                const rect = lastNodeElement.getBoundingClientRect();
                newLeft = (rect.right - canvasRect.left + 50) + 'px'; // 50px à direita do último nó
                newTop = (rect.top - canvasRect.top) + 'px';
            } else {
                // Fallback se o último nó não for encontrado
                newLeft = '100px';
                newTop = '100px';
            }
        } else {
            // Se não houver nós, posicione no canto superior esquerdo
            newLeft = '100px';
            newTop = '100px';
        }

        const newNode = addNode(type, { position: { left: newLeft, top: newTop } });
        focusOnNode(newNode.id);
        return newNode;
    }

    function addNode(type, data = null) {
    const nodeId = data && data.id ? data.id : 'node_' + Date.now();
    const nodeDiv = document.createElement('div');
    nodeDiv.id = nodeId;
    nodeDiv.className = `node node-${type}`;
    nodeDiv.style.left = data && data.position ? data.position.left : '100px';
    nodeDiv.style.top = data && data.position ? data.position.top : '100px';

    const defaultContent = getDefaultContent(type);
    const newNode2 = {
        id: nodeId,
        type: type,
        content: data && data.content ? data.content : defaultContent,
        inputKey: data && data.inputKey ? data.inputKey : '',
        conditionType: data && data.conditionType ? data.conditionType : '',
        conditionValue: data && data.conditionValue ? data.conditionValue : '',
        position: { left: nodeDiv.style.left, top: nodeDiv.style.top },
        duration: data && data.duration ? data.duration : '',
        groupId: data && data.groupId  ? data.groupId  : '',
    };

    let nodeContent = `
        <div class="node-header">
            <span>${getNodeTitle(type)}</span>
            <div>
                <button onclick="editNode('${nodeId}')" class="text-blue-500 hover:text-blue-700">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"></path>
                    </svg>
                </button>
                <button onclick="deleteNode('${nodeId}')" class="text-red-500 hover:text-red-700">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path>
                    </svg>
                </button>
            </div>
        </div>
        <div class="node-content" id="content_${nodeId}">
            ${getNodeContent(type, newNode2)}
        </div>
        <div class="node-footer"></div>
    `;

    nodeDiv.innerHTML = nodeContent;
    document.getElementById('canvas').appendChild(nodeDiv);


        jsPlumbInstance.draggable(nodeDiv, {
            grid: [10, 10],
            containment: 'parent'
        });
        jsPlumbInstance.addEndpoint(nodeDiv, {
            anchor: "Right",
            isSource: true,
            isTarget: false,
            maxConnections: -1
        });
        jsPlumbInstance.addEndpoint(nodeDiv, {
            anchor: "Left",
            isSource: false,
            isTarget: true,
            maxConnections: -1
        });

        if (type === 'condition') {
            jsPlumbInstance.addEndpoint(nodeDiv, {
            anchor: "Bottom",
            isSource: true,
            isTarget: false,
            maxConnections: 1,
            cssClass: "endpoint-no",
            overlays: [
                ["Label", { 
                    label: "Não", 
                    location: [0.5, 1.5],
                    cssClass: "endpoint-label"
                }]
            ]
        });
        jsPlumbInstance.addEndpoint(nodeDiv, {
            anchor: "Right",
            isSource: true,
            isTarget: false,
            maxConnections: 1,
            cssClass: "endpoint-yes",
            overlays: [
                ["Label", { 
                    label: "Sim", 
                    location: [1.5, 0.5],
                    cssClass: "endpoint-label"
                }]
            ]
        });
    } else {
        jsPlumbInstance.addEndpoint(nodeDiv, {
            anchor: "Right",
            isSource: true,
            isTarget: false,
            maxConnections: -1
        });
        jsPlumbInstance.addEndpoint(nodeDiv, {
            anchor: "Left",
            isSource: false,
            isTarget: true,
            maxConnections: -1
        });
    }

       

        nodes.push(newNode2);
        updateNodeDisplay(newNode2);

        if (['image', 'audio', 'video'].includes(type)) {
        const mediaPreview = document.createElement('div');
        mediaPreview.className = 'media-preview mt-2';
        mediaPreview.id = `preview_${nodeId}`;
        nodeDiv.querySelector('.node-content').appendChild(mediaPreview);
        updateMediaPreview(nodeId, data ? data.content : '');
    }


        onNodeChange();

        return newNode2;
    }

    function getNodeTitle(type) {
    const titles = {
        message: 'Mensagem',
        input: 'Input',
        condition: 'Condição',
        wait: 'Espera',
        image: 'Imagem',
        audio: 'Áudio',
        video: 'Vídeo',
        file: 'Arquivo',
        typing: 'Digitando',
        recordAudio: 'Gravando Áudio',
        addToGroup: 'Adicionar ao Grupo',
        removeFromGroup: 'Remover do Grupo',
        sendFile: 'Enviar Arquivo',
        visualize: 'Visualizar'
    };
    return titles[type] || 'Nó';
}

function getNodeContent(type, data) {
    if (data) {
        switch (type) {
            case 'message':
                return `<p>${data.content || 'Nova mensagem'}</p>`;
            case 'input':
                return `<p>${data.content || 'Digite sua pergunta'} (${data.inputKey || 'Sem chave'})</p>`;
            case 'condition':
                return `<p>Se ${data.inputKey || 'input'} ${data.conditionType || 'equals'} "${data.conditionValue || ''}"</p>`;
            case 'wait':
                return `<p>Esperar ${data.content || '5'} segundos</p>`;
            case 'image':
                return `<p>Imagem: ${data.content || 'URL da imagem'}</p>`;
            case 'audio':
                return `<p>Áudio: ${data.content || 'URL do áudio'}</p>`;
            case 'video':
                return `<p>Vídeo: ${data.content || 'URL do vídeo'}</p>`;
            case 'file':
                return `<p>Arquivo: ${data.content || 'URL do arquivo'}</p>`;
            case 'typing':
                return `<p>Digitando por ${data.duration || '5'} segundos</p>`;
            case 'recordAudio':
                return `<p>Gravando áudio por ${data.duration || '5'} segundos</p>`;
            case 'addToGroup':
                return `<p>Adicionar ao grupo: ${data.groupId || 'Não selecionado'}</p>`;
            case 'removeFromGroup':
                return `<p>Remover do grupo: ${data.groupId || 'Não selecionado'}</p>`;
            case 'sendFile':
                return `<p>Enviar arquivo: ${data.fileUrl || 'URL não definida'}</p>`;
            case 'visualize':
                return `<p>Visualizar mensagem</p>`;
            default:
                return `<p>${data.content || 'Novo conteúdo'}</p>`;
        }
    }
    return '<p>Clique para editar</p>';
}

    function getDefaultContent(type) {
        const defaults = {
            message: 'Nova mensagem',
            input: 'Digite sua pergunta',
            condition: 'Condição',
            wait: '5',
            image: 'URL da imagem',
            audio: 'URL do áudio',
            video: 'URL do vídeo',
            file: 'URL do arquivo'
        };
        return defaults[type] || '';
    }

    
    function editNode(nodeId) {
        const node = nodes.find(n => n.id === nodeId);
        if (!node) return;

        editingNodeId = nodeId;
        document.getElementById('modalTitle').textContent = `Editar ${getNodeTitle(node.type)}`;
        let content = '';

        switch (node.type) {
         
            case 'image':
            case 'audio':
            case 'video':
            case 'file':
                content = `
                    <textarea id="nodeContent" class="w-full p-2 border rounded" rows="4">${node.content}</textarea>
                    
                `;
                break;
                case 'message':
    content = `
    <div class="space-y-4">
        <div>
            <label for="nodeContent" class="block text-sm font-medium text-gray-700 mb-1">Mensagem</label>
            <textarea id="nodeContent" class="w-full p-2 border rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500" rows="4" placeholder="Digite sua mensagem aqui...">${node.content}</textarea>
        </div>
        
        <div class="flex items-center space-x-2">
            <div class="flex-grow">
                <label for="placeholderSelect" class="block text-sm font-medium text-gray-700 mb-1">Inserir resposta salva</label>
                <select id="placeholderSelect" class="w-full p-2 border rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500">
                    <option value="">Selecione uma resposta</option>
                    ${getSavedResponseOptions()}
                </select>
            </div>
            <button onclick="insertPlaceholder()" class="px-4 py-2 bg-indigo-600 text-white rounded-md hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 transition duration-150 ease-in-out mt-6">
                Inserir
            </button>
        </div>
        
        <div>
            <p class="text-sm text-gray-500 mt-2">Respostas de inputs disponíveis:</p>
            <div id="availablePlaceholders" class="mt-1 flex flex-wrap gap-2">
                ${getAvailablePlaceholders()}
            </div>
        </div>
    </div>`;
    break;
            case 'input':
            node.saveResponse = node.saveResponse !== undefined ? node.saveResponse : true;

                content = `
                  <!-- No modal de edição do nó de input -->
<input type="text" id="nodeContent" class="w-full p-2 border rounded mb-2" value="${node.content}" placeholder="Pergunta">
<input type="text" id="inputKey" class="w-full p-2 border rounded mb-2" value="${node.inputKey || ''}" placeholder="Chave do input (ex: pergunta1)">
<div class="flex items-center mb-2">
  <input type="checkbox" id="saveResponse" class="mr-2" ${node.saveResponse !== false ? 'checked' : ''}>

    <label for="saveResponse">Salvar resposta do usuário</label>
</div>
                `;
                break;
                case 'condition':
    const inputNodes = nodes.filter(n => n.type === 'input');
    const inputOptions = inputNodes
        .map(n => `<option value="${n.inputKey}" ${node.inputKey === n.inputKey ? 'selected' : ''}>${n.inputKey}</option>`)
        .join('');
    
    content = `
        <select id="inputKeySelect" class="w-full p-2 border rounded mb-2">
            <option value="">Selecione um input</option>
            ${inputOptions}
        </select>
        <select id="conditionType" class="w-full p-2 border rounded mb-2">
            <option value="equals" ${node.conditionType === 'equals' ? 'selected' : ''}>Igual a</option>
            <option value="contains" ${node.conditionType === 'contains' ? 'selected' : ''}>Contém</option>
            <option value="startsWith" ${node.conditionType === 'startsWith' ? 'selected' : ''}>Começa com</option>
            <option value="endsWith" ${node.conditionType === 'endsWith' ? 'selected' : ''}>Termina com</option>
        </select>
        <input type="text" id="conditionValue" class="w-full p-2 border rounded mb-2" value="${node.conditionValue || ''}" placeholder="Valor da condição">
    `;
    break;
            case 'wait':
                content = `
                    <input type="number" id="nodeContent" class="w-full p-2 border rounded" value="${node.content}" min="1" max="300" placeholder="Tempo de espera em segundos">
                `;
                break;

                case 'typing':
        case 'recordAudio':
            content = `
                <div class="form-control">
                    <label class="label">
                        <span class="label-text">Duração (segundos)</span>
                    </label>
                    <input type="number" id="actionDuration" class="input input-bordered" value="${node.duration || 5}" min="1" max="60">
                </div>
            `;
            break;
            case 'addToGroup':
        case 'removeFromGroup':
            content = `
                <div class="form-control">
                    <label class="label">
                        <span class="label-text">Selecione a Instância</span>
                    </label>
                    <select id="instanceSelect" class="select select-bordered w-full mb-2" onchange="loadGroups()">
                        <option value="">Selecione uma instância</option>
                    </select>
                </div>
                <div class="form-control">
                    <label class="label">
                        <span class="label-text">Selecione o Grupo</span>
                    </label>
                    <select id="groupSelect" class="select select-bordered w-full">
                        <option value="">Primeiro selecione uma instância</option>
                    </select>
                </div>
            `;
            break;
        case 'sendFile':
            content = `
                <div class="form-control">
                    <label class="label">
                        <span class="label-text">URL do Arquivo</span>
                    </label>
                    <input type="text" id="fileUrl" class="input input-bordered" value="${node.fileUrl || ''}">
                </div>
            `;
            break;
        case 'visualize':
            content = `
                <p>Este nó marca a mensagem como visualizada.</p>
            `;
            break;

        }

        document.getElementById('modalContent').innerHTML = content;
        document.getElementById('editModal').classList.remove('hidden');
        

        if (node.type === 'addToGroup' || node.type === 'removeFromGroup') {
        loadUserInstances();
        if (node.instanceKey) {
            document.getElementById('instanceSelect').value = node.instanceKey;
            loadGroups(node.groupId);
        }
    }
    }

    function loadUserInstances() {
    const instanceSelect = document.getElementById('instanceSelect');
    instanceSelect.innerHTML = '<option value="" disabled selected>Escolha uma instância</option>';
    
    const instances = <%- JSON.stringify(user.whatsappInstances) %>;
    
    instances.forEach(instance => {
        const option = document.createElement('option');
        option.value = instance.key;
        option.textContent = instance.name;
        instanceSelect.appendChild(option);
    });
}

function loadGroups(selectedGroupId) {
    const instanceSelect = document.getElementById('instanceSelect');
    const groupSelect = document.getElementById('groupSelect');
    const selectedInstance = instanceSelect.value;

    if (!selectedInstance) {
        groupSelect.innerHTML = '<option value="">Primeiro selecione uma instância</option>';
        return;
    }

    groupSelect.innerHTML = '<option value="">Carregando grupos...</option>';

    fetch(`/group/all?instanceKey=${selectedInstance}`)
        .then(response => response.json())
        .then(data => {
            if (!data.error) {
                groupSelect.innerHTML = Object.entries(data.data).map(([id, group]) => 
                    `<option value="${id}" ${id === selectedGroupId ? 'selected' : ''}>${group.subject}</option>`
                ).join('');
                
                if (groupSelect.innerHTML === '') {
                    groupSelect.innerHTML = '<option value="">Nenhum grupo encontrado</option>';
                }
            } else {
                groupSelect.innerHTML = '<option value="">Erro: ${data.message}</option>';
            }
        })
        .catch(error => {
            console.error('Erro ao carregar grupos:', error);
            groupSelect.innerHTML = '<option value="">Erro ao carregar grupos</option>';
        });
}

    function getAvailablePlaceholders() {
    return nodes
        .filter(n => n.type === 'input' && n.saveResponse)
        .map(n => `<span class="inline-flex items-center px-2 py-1 rounded-full text-xs font-medium bg-indigo-100 text-indigo-800 cursor-pointer hover:bg-indigo-200" onclick="insertSpecificPlaceholder('${n.inputKey}')">{{${n.inputKey}}}</span>`)
        .join('');
}

function insertSpecificPlaceholder(key) {
    const textarea = document.getElementById('nodeContent');
    const placeholder = `{{${key}}}`;
    insertAtCursor(textarea, placeholder);
}

function insertAtCursor(textarea, text) {
    const startPos = textarea.selectionStart;
    const endPos = textarea.selectionEnd;
    textarea.value = textarea.value.substring(0, startPos) + text + textarea.value.substring(endPos, textarea.value.length);
    textarea.focus();
    textarea.selectionStart = startPos + text.length;
    textarea.selectionEnd = startPos + text.length;
}

function getSavedResponseOptions() {
    return nodes
        .filter(n => n.type === 'input' && n.saveResponse)
        .map(n => `<option value="${n.inputKey}">${n.inputKey}</option>`)
        .join('');
}

function insertPlaceholder() {
    const select = document.getElementById('placeholderSelect');
    const textarea = document.getElementById('nodeContent');
    if (select.value) {
        insertSpecificPlaceholder(select.value);
    }
}

    function saveNodeEdit() {
    const node = nodes.find(n => n.id === editingNodeId);
    if (!node) return;

    const contentElement = document.getElementById('nodeContent');
    if (contentElement) {
        node.content = contentElement.value;
    }

    
    switch (node.type) {
        // ... (mantenha os casos existentes)
        case 'input':
        const inputKeyElement = document.getElementById('inputKey');
        const saveResponseElement = document.getElementById('saveResponse');
        if (inputKeyElement) {
            node.inputKey = inputKeyElement.value;
        }
        if (saveResponseElement) {
            node.saveResponse = saveResponseElement.checked;
        }
            break

            case 'condition':
            const inputKeySelect = document.getElementById('inputKeySelect');
        const conditionTypeElement = document.getElementById('conditionType');
        const conditionValueElement = document.getElementById('conditionValue');
        if (inputKeySelect && conditionTypeElement && conditionValueElement) {
            node.inputKey = inputKeySelect.value;
            node.conditionType = conditionTypeElement.value;
            node.conditionValue = conditionValueElement.value;
        }
                break


        case 'typing':
        case 'recordAudio':
            node.duration = parseInt(document.getElementById('actionDuration').value);
            break;
         case 'addToGroup':
        case 'removeFromGroup':
            node.instanceKey = document.getElementById('instanceSelect').value;
            node.groupId = document.getElementById('groupSelect').value;
            break;

        // ... (outros casos)
    
        case 'sendFile':
            node.fileUrl = document.getElementById('fileUrl').value;
            break;
    }




    updateNodeDisplay(node);
    if (['image', 'audio', 'video'].includes(node.type)) {
        updateMediaPreview(node.id, node.content);
    }

    closeModal();
    onNodeChange();
}

function updateNodeDisplay(node) {
    const contentElement = document.getElementById(`content_${node.id}`);
    if (contentElement) {
        let displayContent = node.content;


        switch (node.type) {
            // ... (mantenha os casos existentes)
            case 'typing':
                displayContent = `Digitar por ${node.duration} segundos`;
                break;
            case 'recordAudio':
                displayContent = `Gravar áudio por ${node.duration} segundos`;
                break;
                case 'addToGroup':
                displayContent = `Adicionar ao grupo: ${node.groupId || 'Não selecionado'} (Instância: ${node.instanceKey || 'Não selecionada'})`;
                break;
            case 'removeFromGroup':
                displayContent = `Remover do grupo: ${node.groupId || 'Não selecionado'} (Instância: ${node.instanceKey || 'Não selecionada'})`;
                break;

            case 'sendFile':
                displayContent = `Enviar arquivo: ${node.fileUrl}`;
                break;
            case 'visualize':
                displayContent = 'Visualizar mensagem';
                break;
                case 'condition':
                displayContent = `Se ${node.inputKey} ${node.conditionType} "${node.conditionValue}"`;
                break;
            case 'input':
            displayContent = `${node.content} (${node.inputKey})`;
                break;
        }

      
        contentElement.innerHTML = `<p>${displayContent}</p>`;
    }
}

function updateMediaPreview(nodeId, url) {
    const previewElement = document.getElementById(`preview_${nodeId}`);
    if (!previewElement) return;

    const node = nodes.find(n => n.id === nodeId);
    if (!node) return;

    switch (node.type) {
        case 'image':
            previewElement.innerHTML = `<img src="${url}" alt="Preview" class="media-preview">`;
            break;
        case 'audio':
            previewElement.innerHTML = `<audio controls src="${url}" class="media-preview"></audio>`;
            break;
        case 'video':
            previewElement.innerHTML = `<video controls src="${url}" class="media-preview"></video>`;
            break;
    }
}

    function closeModal() {
        document.getElementById('editModal').classList.add('hidden');
        editingNodeId = null;
    }

    function deleteNode(nodeId) {
        Swal.fire({
            title: 'Tem certeza?',
            text: "Você não poderá reverter isso!",
            icon: 'warning',
            showCancelButton: true,
            confirmButtonColor: '#3085d6',
            cancelButtonColor: '#d33',
            confirmButtonText: 'Sim, delete!',
            cancelButtonText: 'Cancelar'
        }).then((result) => {
            if (result.isConfirmed) {
                const nodeElement = document.getElementById(nodeId);
                if (nodeElement) {
                    jsPlumbInstance.remove(nodeElement);
                }
                nodes = nodes.filter(n => n.id !== nodeId);
                connections = connections.filter(c => c.sourceId !== nodeId && c.targetId !== nodeId);
                Swal.fire(
                    'Deletado!',
                    'O nó foi deletado.',
                    'success'
                );
                onNodeChange();
            }
        });
    }

    function saveFunnel() {
    const funnelData = {
        name: document.getElementById('funnelName').textContent,
        nodes: nodes.map(node => {
            const nodeElement = document.getElementById(node.id);
            const nodeData = {
                id: node.id,
                type: node.type,
                content: node.content,
                position: {
                    left: nodeElement ? nodeElement.style.left : node.position.left,
                    top: nodeElement ? nodeElement.style.top : node.position.top
                }
            };

            // Adicionar dados específicos para cada tipo de nó
            switch (node.type) {
                case 'input':
                    nodeData.inputKey = node.inputKey;
                    nodeData.saveResponse = node.saveResponse;
                    break;
                case 'condition':
                    nodeData.inputKey = node.inputKey;
                    nodeData.conditionType = node.conditionType;
                    nodeData.conditionValue = node.conditionValue;
                    break;
                case 'typing':
                case 'recordAudio':
                    nodeData.duration = node.duration;
                    break;
                    case 'addToGroup':
                case 'removeFromGroup':
                    nodeData.instanceKey = node.instanceKey;
                    nodeData.groupId = node.groupId;
                    break;
                case 'sendFile':
                    nodeData.fileUrl = node.fileUrl;
                    break;
                case 'image':
                case 'audio':
                case 'video':
                    nodeData.caption = node.caption;
                    break;
            }

            return nodeData;
        }),
        connections: jsPlumbInstance.getConnections().map(conn => ({
            sourceId: conn.sourceId,
            targetId: conn.targetId,
            anchors: [conn.endpoints[0].anchor.type, conn.endpoints[1].anchor.type]
        }))
    };

    fetch('/funnels/api/update/<%= funnel.id %>', {
        method: 'PUT',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify(funnelData),
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            Swal.fire(
                'Salvo!',
                'Seu funil foi salvo com sucesso.',
                'success'
            );
        } else {
            throw new Error(data.error || 'Erro ao salvar o funil');
        }
    })
    .catch(error => {
        Swal.fire(
            'Erro!',
            'Ocorreu um erro ao salvar o funil: ' + error.message,
            'error'
        );
    });
}

    function createConnection(source, target, anchors) {
    const sourceNode = nodes.find(n => n.id === source);
    const isCondition = sourceNode && sourceNode.type === 'condition';
    const isNoConnection = anchors && anchors[0] === 'Bottom';

    let color = '#6366F1'; // cor padrão
    if (isCondition) {
        color = isNoConnection ? '#F56565' : '#48BB78';
    }

    jsPlumbInstance.connect({
        source: source,
        target: target,
        paintStyle: { stroke: color, strokeWidth: 2 },
        connector: ["Bezier", { curviness: 50 }],
        anchors: anchors || ["Right", "Left"],
        endpoint: ["Dot", { radius: 5 }],
    });
}

    function getConnectionColor(connection) {
        const sourceNode = nodes.find(n => n.id === connection.sourceId);
        if (sourceNode && sourceNode.type === 'condition') {
            return connection.anchors[0] === 'Bottom' ? '#F56565' : '#48BB78';
        }
        return '#6366F1';
    }

    function zoomIn() {
        zoom(0.1);
    }

    function zoomOut() {
        zoom(-0.1);
    }

    function zoom(delta) {
        const container = document.querySelector('.canvas-container');
        const canvas = document.getElementById('canvas');

        // Obter a posição do scroll antes do zoom
        const scrollXRatio = container.scrollLeft / (canvas.scrollWidth - container.clientWidth);
        const scrollYRatio = container.scrollTop / (canvas.scrollHeight - container.clientHeight);

        zoomLevel += delta;
        zoomLevel = Math.max(0.5, Math.min(zoomLevel, 2)); // Limita o zoom entre 0.5 e 2
        canvas.style.transform = `scale(${zoomLevel})`;
        jsPlumbInstance.setZoom(zoomLevel);

        // Reposicionar o scroll após o zoom
        setTimeout(() => {
            container.scrollLeft = scrollXRatio * (canvas.scrollWidth - container.clientWidth);
            container.scrollTop = scrollYRatio * (canvas.scrollHeight - container.clientHeight);
        }, 0);

        repositionConnections();
    }

    function repositionConnections() {
        jsPlumbInstance.repaintEverything();
    }

    function updateCanvasSize() {
        const canvas = document.getElementById('canvas');
        const nodes = document.querySelectorAll('.node');
        let maxX = 0;
        let maxY = 0;

        nodes.forEach(node => {
            const rect = node.getBoundingClientRect();
            maxX = Math.max(maxX, rect.right);
            maxY = Math.max(maxY, rect.bottom);
        });

        canvas.style.width = Math.max(5000, maxX + 500) + 'px';
        canvas.style.height = Math.max(5000, maxY + 500) + 'px';
    }

    function onNodeChange() {
        updateCanvasSize();
        repositionConnections();
    }

    function centerCanvas() {
        const container = document.querySelector('.canvas-container');
        const canvas = document.getElementById('canvas');
        
        container.scrollLeft = (canvas.scrollWidth - container.clientWidth) / 2;
        container.scrollTop = (canvas.scrollHeight - container.clientHeight) / 2;
    }

    function focusOnNode(nodeId) {
        const node = document.getElementById(nodeId);
        if (node) {
            const container = document.querySelector('.canvas-container');
            const nodeRect = node.getBoundingClientRect();
            const containerRect = container.getBoundingClientRect();

            const scrollX = nodeRect.left + nodeRect.width / 2 - containerRect.width / 2;
            const scrollY = nodeRect.top + nodeRect.height / 2 - containerRect.height / 2;

            container.scrollTo({
                left: scrollX,
                top: scrollY,
                behavior: 'smooth'
            });
        }
    }

    function startDragging(e) {
        isDragging = true;
        startX = e.pageX - container.offsetLeft;
        startY = e.pageY - container.offsetTop;
        scrollLeft = container.scrollLeft;
        scrollTop = container.scrollTop;
    }

    function drag(e) {
        if (!isDragging) return;
        e.preventDefault();
        const x = e.pageX - container.offsetLeft;
        const y = e.pageY - container.offsetTop;
        const walkX = (x - startX) * 2;
        const walkY = (y - startY) * 2;
        container.scrollLeft = scrollLeft - walkX;
        container.scrollTop = scrollTop - walkY;
    }

    function stopDragging() {
        isDragging = false;
    }

    // Adicionar listeners para arrastar e soltar
    jsPlumbInstance.bind("connection", function(info) {
        connections.push({
            sourceId: info.sourceId,
            targetId: info.targetId,
            anchors: info.connection.endpoints.map(ep => ep.anchor.type)
        });
    });

    jsPlumbInstance.bind("connectionDetached", function(info) {
        connections = connections.filter(conn =>
            conn.sourceId !== info.sourceId || conn.targetId !== info.targetId
        );
    });

    // Função para atualizar a posição dos nós após arrastar
    jsPlumbInstance.bind("connectionMoved", function(info) {
        const nodeElement = document.getElementById(info.newSourceId);
        const node = nodes.find(n => n.id === info.newSourceId);
        if (node && nodeElement) {
            node.position = {
                left: nodeElement.style.left,
                top: nodeElement.style.top
            };
        }
    });

    // Atualizar posições dos nós ao arrastar
    jsPlumbInstance.bind("drag:stop", function (info) {
        const nodeId = info.el.id;
        const node = nodes.find(n => n.id === nodeId);
        if (node) {
            node.position = {
                left: info.finalPos[0] + 'px',
                top: info.finalPos[1] + 'px'
            };
        }
        onNodeChange();
    });

    
    // Atualizar o tamanho do canvas quando a janela for redimensionada
    window.addEventListener('resize', updateCanvasSize);
</script>


<script>
    // menu.js

(function() {
    const menuItems = {
        messages: [
            { type: 'message', icon: 'M8 10h.01M12 10h.01M16 10h.01M9 16H5a2 2 0 01-2-2V6a2 2 0 012-2h14a2 2 0 012 2v8a2 2 0 01-2 2h-5l-5 5v-5z', label: 'Mensagem' },
            { type: 'image', icon: 'M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z', label: 'Imagem' },
            { type: 'audio', icon: 'M9 19V6l12-3v13M9 19c0 1.105-1.343 2-3 2s-3-.895-3-2 1.343-2 3-2 3 .895 3 2zm12-3c0 1.105-1.343 2-3 2s-3-.895-3-2 1.343-2 3-2 3 .895 3 2zM9 10l12-3', label: 'Áudio' },
            { type: 'video', icon: 'M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M5 18h8a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z', label: 'Vídeo' },
         //   { type: 'file', icon: 'M7 21h10a2 2 0 002-2V9.414a1 1 0 00-.293-.707l-5.414-5.414A1 1 0 0012.586 3H7a2 2 0 00-2 2v14a2 2 0 002 2z', label: 'Arquivo' },
        ],
        logic: [
            { type: 'input', icon: 'M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z', label: 'Input' },
            { type: 'condition', icon: 'M8.228 9c.549-1.165 2.03-2 3.772-2 2.21 0 4 1.343 4 3 0 1.4-1.278 2.575-3.006 2.907-.542.104-.994.54-.994 1.093m0 3h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z', label: 'Condição' },
            { type: 'wait', icon: 'M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z', label: 'Espera' },
        ],
        actions: [
        { type: 'typing', icon: 'M3 5h12M9 3v2m1.048 9.5A18.022 18.022 0 016.412 9m6.088 9h7M11 21l5-10 5 10M12.751 5C11.783 10.77 8.07 15.61 3 18.129', label: 'Digitar' },
        { type: 'recordAudio', icon: 'M19 11a7 7 0 01-7 7m0 0a7 7 0 01-7-7m7 7v4m0 0H8m4 0h4m-4-8a3 3 0 01-3-3V5a3 3 0 116 0v6a3 3 0 01-3 3z', label: 'Gravar Áudio' },
        { type: 'addToGroup', icon: 'M18 9v3m0 0v3m0-3h3m-3 0h-3m-2-5a4 4 0 11-8 0 4 4 0 018 0zM3 20a6 6 0 0112 0v1H3v-1z', label: 'Add ao Grupo' },
        { type: 'removeFromGroup', icon: 'M13 7a4 4 0 11-8 0 4 4 0 018 0zM9 14a6 6 0 00-6 6v1h12v-1a6 6 0 00-6-6zm7-8h6m-3-3v6', label: 'Remover do Grupo' },
      //  { type: 'sendFile', icon: 'M7 21h10a2 2 0 002-2V9.414a1 1 0 00-.293-.707l-5.414-5.414A1 1 0 0012.586 3H7a2 2 0 00-2 2v14a2 2 0 002 2z', label: 'Enviar Arquivo' },
   //     { type: 'visualize', icon: 'M15 12a3 3 0 11-6 0 3 3 0 016 0z', label: 'Visualizar' },
    ]
    };

    function showTab(tabName) {
        // Atualizar tabs ativas
        document.querySelectorAll('.menu-tab').forEach(tab => {
            tab.classList.remove('active');
        });

        const activeTab = document.querySelector(`.menu-tab[onclick*="${tabName}"]`);
        if (activeTab) {
            activeTab.classList.add('active');
        } else {
            console.warn(`Tab "${tabName}" não encontrada`);
        }

        // Atualizar conteúdo
        const content = document.getElementById('menuContent');
        if (content && menuItems[tabName]) {
            content.innerHTML = menuItems[tabName].map(item => `
                <div class="menu-item" data-type="${item.type}">
                    <svg fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="${item.icon}"></path>
                    </svg>
                    <span>${item.label}</span>
                </div>
            `).join('');
        } else {
            console.warn(`Conteúdo ou itens de menu para "${tabName}" não encontrados`);
        }
    }

    function initMenu() {
        // Delegação de eventos para os itens do menu
        document.getElementById('menuContent').addEventListener('click', function(event) {
            const menuItem = event.target.closest('.menu-item');
            if (menuItem) {
                const type = menuItem.getAttribute('data-type');
                if (window.addNewNode) {
                    window.addNewNode(type);
                } else {
                    console.warn('A função addNewNode não está disponível.');
                }
            }
        });

        // Adicionar event listeners para as tabs
        document.querySelectorAll('.menu-tab').forEach(tab => {
            tab.addEventListener('click', function() {
                const tabName = this.getAttribute('onclick').match(/'(\w+)'/)[1];
                showTab(tabName);
            });
        });

        // Inicializar com a tab de mensagens
        showTab('messages');
    }

    // Executar inicialização quando o DOM estiver pronto
    document.addEventListener('DOMContentLoaded', initMenu);

    // Expor funções necessárias globalmente
    window.showTab = showTab;
})();
</script>
</body>
</html>